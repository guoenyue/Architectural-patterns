<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>AMD-异步模块模式</title>
</head>
<body>
	<div id="box">233333333333333333</div>
	<script type="text/javascript">
		/*
			AMD 全拼是Asynchrinous Module Definition
			意为异步模块模式，请求发出后，继续其他业务逻辑，直到模块加载完成执行后续的逻辑，实现模块开发中对模块加
			载完成后的引用。
			真正的依赖注入。上一章的那个模块仅仅是单纯的同步模块处理，可以简单的理解成就是一个命名空间的变化。
		*/
		~(function(F){
			var moduleCache={};
		})((function(){
			return window.F={};
		})());
		F.module=function(url,modDeps,modCallback){
			//说明，这里函数的三个形参貌似没什么作用，只是一个指示的作用。
			//接下来的函数中会将参数拆分组合成需要的形式。

				//此处将参数转换成数组
			var args=[].slice.call(arguments),
				//定义最后一个参数是回调函数
				callback=args.pop(),
				//倒数第二个参数若是数组则将其作为依赖包（数组格式）
				deps=(args.length&&args[args.length-1] instanceof Array)?args.pop():[],
				//若上一步没有找到依赖包则将其设置为路径，否则为null
				url=args.length?args.pop():null,
				//定义一个空数组，以便接下来缓存模块中的依赖包
				params=[],
				//初始化依赖包数量为0，也是当前依赖的指针
				depsCount=0,
				//
				i=0,
				len;
				//如果有依赖包请求，即依赖包数组不为0
				if(len=deps.length){
					//遍历所有依赖包
					while(i<len){
						//通过闭包接受第几个依赖
						(function(i){
							//下边的loadModule应该是个异步函数，同步的话，depsCount++--没什么卵用，也就不必判断===0
							//这边应该是等待所有的loadModule函数运行完，即模块全部加载完。此时depsCount才===0；此处
							//应该是一个异步关键点。
							depsCount++;
							//加载模块
							loadModule(deps[i],function(mod){
								//缓存模块
								params[i]=mod;
								//每完成一次回调将依赖包指针回拨一次
								depsCount--;
								//当所有的依赖模块（包）全都加载完成
								if(depsCount===0){
									//调用设置模块函数
									setModule(url,params,callback);
								}
							});
						})(i);
						i++;
					}
				}else{
					//如果没有依赖包请求，即依赖包数组为空，那么就将该函数作为设置依赖
					setModule(url,[],callback);
				}
		};
		//缓存模块，以便下次请求相同模块时不会再次加载模块所在文件。
		var moduleCache={},
		 	setModule=function(moduleName,params,callback){
		 		//当使用模块时，params为所有的依赖模块，callback
		 		//console.log(moduleName);
		 		//moduleName为模块名称，设置模块时候才有，调用模块时此项为null
		 		var _module,fn;
		 		if(moduleCache[moduleName]){
		 			//缓存模块
		 			_module=moduleCache[moduleName];
		 			//改变当前模块状态为加载完成
		 			_module.status="loaded";
		 			//模块的导出格式为callback.apply(_module,params);其中params就是设置时候的空数组
		 			_module.exports=callback?callback.apply(_module,params):null;
		 			//_module.onload指向的是一个数组，这个数组是从moduleCache[moduleName]里来的
		 			while(fn=_module.onload.shift()){
		 				fn(_module.exports);
		 			}
		 		}else{
		 			callback&&callback.apply(null,params);
		 		}
		 	},
		 	loadModule=function(moduleName,callback){
		 		//加载模块
		 		var _module;
		 		//已经加载过该模块
		 		if(moduleCache[moduleName]){
		 			_module=moduleCache[moduleName];
		 			if(_module.status==='loaded'){
		 				//加载完成调用回调函数，放到队列中通过setTimeout设置成异步队列
		 				//与上边那个拨动指针的互相照应，每次有模块加载完成都调用一下那个回调函数，
		 				//在那个回调函数中设置了，当所有的模块加载完成之后的逻辑，所以此处只每次
		 				//完成之后调用回调函数即可无需额外设置
		 				setTimeout(callback,0,_module.exports);
		 			}else{
		 				//如果模块没有加载完成，那么将回调函数放到onload数组中
		 				_module.onload.push(callback);
		 			}
		 		}else{
		 			//如果模块没有加载过，那么将模块的状态设置成loading，并记录加载完成之后的回调函数
		 			//数组，并且加载模块地址
		 			moduleCache[moduleName]={
		 				moduleName:moduleName,
		 				status:"loading",
		 				exports:null,
		 				onload:[callback]
		 			};
		 			loadScript(getUrl(moduleName));
		 		}
		 	},
		 	//获取url函数,该函数保证url是js,而且模块的对应名字可以写文件类型，也可省略
		 	getUrl=function(moduleName){
		 		return String(moduleName).replace(/\.js$/g,'')+".js";
		 	},
		 	//加载脚本文件函数
		 	loadScript=function(src){
		 		var _script=document.createElement("script");
		 		_script.type="text/JavaScript";
		 		_script.charset="UTF-8";
		 		_script.async=true;
		 		_script.src=src;
		 		document.getElementsByTagName("head")[0].appendChild(_script);
		 	};



		 F.module(["dom","event"],function(dom,event){
		 	//dom.html("box","害怕不，呵呵呵呵！")
		 	event.on(dom.g("box"),"click",function(e){
		 		console.log(e);
		 		alert("我的天，敲可爱！");
		 	});
		 });

		 F.module(["dom"],function(dom){
		 	dom.html("box","哈哈哈哈，害怕不！");
		 });
	</script>
</body>
</html>